<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Call Map v1.6</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
    <!-- Password Modal -->
    <div id="password-modal">
        <div class="modal-content">
            <h2>Authentication Required</h2>
            <p>Please enter your access token to continue:</p>
            <input type="password" id="password-input" placeholder="Enter your token">
            <button id="submit-password">Connect</button>
        </div>
    </div>

    <div id="header">
        <div class="logo">
            <div class="logo-icon"><i class="fas fa-map-marker-alt"></i></div>
            <h1>Live Call Map v1.6 - Past call logs working - Area searching to add</h1>
        </div>
    </div>
    
    <div id="container">
        <div id="sidebar">
            <div class="sidebar-section">
                <h3>Filters</h3>
                <div class="filters">
                    <div class="filter-group">
                        <label for="time-filter">Time Range</label>
                        <select id="time-filter">
                            <option value="1">Last minute</option>
                            <option value="5">Last 5 minutes</option>
                            <option value="15" selected>Last 15 minutes</option>
                            <option value="30">Last 30 minutes</option>
                            <option value="60">Last hour</option>
                            <option value="all">All Day</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="area-filter">Area (Not working yet)</label>
                        <select id="area-filter">
                            <option value="all" selected>All Areas</option>
                            <option value="north">North Region</option>
                            <option value="south">South Region</option>
                            <option value="east">East Region</option>
                            <option value="west">West Region</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="cluster-slider">Cluster Density (0 = off)</label>
                        <input type="range" id="cluster-slider" min="5" max="100" step="5" value="30">
                        <span id="cluster-slider-value">30</span>
                    </div>
                </div>
            </div>
            
            <div class="sidebar-section">
                <h3>Statistics</h3>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-value" id="total-calls">0</div>
                        <div class="stat-label">Total Calls on Screen</div>
                    </div>
                </div>
            </div>
            
            <!-- Cabinets section (collapsible) -->
            <div class="sidebar-section" id="cabinet-section">
                <h3>
                    <span class="collapsible-header">Cabinets</span>
                    <span class="toggle-icon">‚ñº</span>
                </h3>
                <div id="cabinet-list" style="display: flex; flex-direction: column; gap: 4px; font-size: 14px;"></div>
            </div>
            
            <!-- Recent Calls section (collapsible) -->
            <div class="sidebar-section" id="calls-section" style="flex: 1; display: flex; flex-direction: column; overflow-y: auto;">
                <h3>
                    <span class="collapsible-header">Calls</span>
                    <span class="toggle-icon">‚ñº</span>
                </h3>
                <div id="calls-list" style="flex: 1; overflow-y: auto;">
                    <!-- Call items will be added here dynamically -->
                </div>
            </div>
        </div>
        
        <div id="map-container">
            <div id="map"></div>
            
            <!-- Draggable, collapsible Map Controls panel -->
            <div id="controls">
                <div id="controls-header">
                    <span>Map Controls</span>
                    <button id="toggle-controls">‚Üì</button>
                </div>
                <div id="controls-content">
                    <div class="control-group">
                        <h3>Map Controls</h3>
                        <div class="button-group">
                            <button id="clearAll"><i class="fas fa-trash"></i> Clear All</button>
                            <button id="clusterView" class="secondary"><i class="fas fa-object-group"></i> Cluster View</button>
                        </div>
                        
                        <div class="heatmap-controls">
                            <div class="heatmap-toggle">
                                <span>Heatmap:</span>
                                <label class="switch">
                                    <input type="checkbox" id="heatmap-toggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            
                            <div class="filter-group">
                                <label for="ttl">Points TTL (sec):</label>
                                <input type="number" id="ttl" value="300" min="5" max="300">
                            </div>
                        </div>
                    </div>
                </div>
                <div id="log" style="display:none;"></div>
                <div id="server-status">
                    <div class="server-dot" id="server-status-dot"></div>
                    <span id="server-status-text">Not connected</span>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
    <script src="https://cdn.ably.io/lib/ably.min-1.js"></script>
    <script>
        // === CONFIG ===
        const ABLY_KEY = ''; // Your Ably key goes here
        const CHANNEL_NAME = 'getting-started-widget'; // channel to subscribe to
        // ==============

        // Initialize the map centered on Birmingham (ignore Scotland)
        const map = L.map('map').setView([52.48, -1.90], 7);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Initialize marker cluster group
        let clusterGroup = L.markerClusterGroup({ maxClusterRadius: 30 });
        map.addLayer(clusterGroup);

        // Initialize heat layer
        const heatLayer = L.heatLayer([], { radius: 25, blur: 15, maxZoom: 17 });
        
        // Store active pings
        const activePings = new Map();
        let callCounter = 0;
        const availableQueues = ["COPS - General", "COPS - Technical", "COPS - Billing"];

        // DOM elements
        const logElement = document.getElementById('log');
        const ttlInput = document.getElementById('ttl');
        const clearAllButton = document.getElementById('clearAll');
        const heatmapToggle = document.getElementById('heatmap-toggle');
        const serverStatusDot = document.getElementById('server-status-dot');
        const serverStatusText = document.getElementById('server-status-text');
        const callsList = document.getElementById('calls-list');
        const totalCallsElement = document.getElementById('total-calls');
        const activeCallsElement = document.getElementById('active-calls');
        
        function updateStats() {
            if (totalCallsElement) {
                // Count the number of active pins visible on the map.
                totalCallsElement.textContent = activePings.size;
            }
            // Optionally update an "Active Calls" stat if needed:
            if (activeCallsElement) {
                activeCallsElement.textContent = activePings.size;
            }
        }
        
        function addLogEntry(message) {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.innerHTML = `<span class="log-time">${timeString}</span> - ${message}`;
            logElement.prepend(logEntry);
            if (logElement.children.length > 10) {
                logElement.removeChild(logElement.lastChild);
            }
        }
        
        function updateServerStatus(connected) {
            if (connected) {
                serverStatusDot.style.background = '#2ecc71';
                serverStatusText.textContent = 'Connected to 8x8 API';
            } else {
                serverStatusDot.style.background = '#e74c3c';
                serverStatusText.textContent = 'Not connected';
            }
        }
        
        function addCallToList(id, number, location, queue) {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            const callItem = document.createElement('div');
            callItem.className = 'call-item';
            callItem.id = `call-${id}`;
            callItem.innerHTML = `
                <div class="call-info">
                    <div class="call-number">${number}</div>
                    <div class="call-time">${timeString}</div>
                    <div class="call-location">${location}</div>
                    <div class="call-queue"><strong>Queue:</strong> ${queue}</div>
                </div>
                <div class="call-actions">
                    <button onclick="focusCall('${id}')">View</button>
                </div>
            `;
            callsList.prepend(callItem);
            if (callsList.children.length > 20) {
                callsList.removeChild(callsList.lastChild);
            }
        }
        
        function focusCall(id) {
            if (activePings.has(id)) {
                const ping = activePings.get(id);
                map.setView(ping.marker.getLatLng(), 15);
                ping.marker.openPopup();
            }
        }
        
        function showPing(id, lat, lng, number, location, ttl = 300000) {
            if (activePings.has(id)) {
                const ping = activePings.get(id);
                ping.marker.setLatLng([lat, lng]);
                ping.lastUpdate = Date.now();
                clearTimeout(ping.timeoutId);
                ping.timeoutId = setTimeout(() => removePing(id), ttl);
                addLogEntry(`Updated ping ${id} at ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
                return ping.marker;
            }
            const queue = availableQueues[Math.floor(Math.random() * availableQueues.length)];
            const marker = L.marker([lat, lng], { icon: getIconForQueue(queue) });
            marker.bindPopup(`
                <div style="padding: 8px;">
                    <strong>Call from:</strong> ${number}<br>
                    <strong>Queue:</strong> ${queue}<br>
                    <strong>Location:</strong> ${location}<br>
                    <strong>Coordinates:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                    <strong>Received:</strong> ${new Date().toLocaleTimeString()}<br>
                    <strong>Cabinet: </strong> ${cabinet}
                </div>
            `);
            clusterGroup.addLayer(marker);
            const timeoutId = setTimeout(() => removePing(id), ttl);
            activePings.set(id, { marker, timeoutId, lastUpdate: Date.now(), number, location, queue });
            updateHeatmap();
            addCallToList(id, number, location, queue);
            callCounter++;
            updateStats();
            addLogEntry(`New call from ${number} at ${location} via ${queue}`);
            return marker;
        }
        
        function removePing(id) {
            if (activePings.has(id)) {
                const ping = activePings.get(id);
                clearTimeout(ping.timeoutId);
                clusterGroup.removeLayer(ping.marker);
                activePings.delete(id);
                const callElement = document.getElementById(`call-${id}`);
                if (callElement) {
                    callElement.style.opacity = '0.5';
                    callElement.style.textDecoration = 'line-through';
                }
                updateHeatmap();
                updateStats();
                addLogEntry(`Removed ping ${id}`);
                return true;
            }
            return false;
        }
        
        function clearAllPings() {
            activePings.forEach((ping, id) => {
                clearTimeout(ping.timeoutId); // (Unused now, but safe to clear)
                clusterGroup.removeLayer(ping.marker);
                const callElement = document.getElementById(`call-${id}`);
                if (callElement) {
                    callsList.removeChild(callElement);
                }
            });
            activePings.clear();
            heatLayer.setLatLngs([]);
            callCounter = 0;
            updateStats();
            addLogEntry('Cleared all points from the map');
        }
        
        function updateHeatmap() {
            const points = [];
            for (const ping of activePings.values()) {
                const latlng = ping.marker.getLatLng();
                points.push([latlng.lat, latlng.lng, 0.5]);
            }
            heatLayer.setLatLngs(points);
        }
        
        function toggleHeatmap() {
            if (map.hasLayer(heatLayer)) {
                map.removeLayer(heatLayer);
                addLogEntry('Heatmap disabled');
            } else {
                map.addLayer(heatLayer);
                addLogEntry('Heatmap enabled');
            }
        }
        
        clearAllButton.addEventListener('click', clearAllPings);
        heatmapToggle.addEventListener('change', toggleHeatmap);
        window.focusCall = focusCall;

        // Define custom icons for different queues
        const blueIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });
        const redIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });
        const greenIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });
        const greyIcon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-grey.png',
            shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });
        function getIconForQueue(queue) {
            if (queue === 'COPS - General') return blueIcon;
            else if (queue === 'COPS - Technical') return redIcon;
            else if (queue === 'COPS - Billing') return greenIcon;
            return greyIcon;
        }

        // Make the controls panel draggable
        (function makeDraggable(){
            const controls = document.getElementById('controls');
            const header = document.getElementById('controls-header');
            let isDragging = false, offsetX = 0, offsetY = 0;
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                offsetX = e.clientX - controls.offsetLeft;
                offsetY = e.clientY - controls.offsetTop;
                controls.style.transition = 'none';
            });
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    controls.style.left = (e.clientX - offsetX) + 'px';
                    controls.style.top = (e.clientY - offsetY) + 'px';
                }
            });
            document.addEventListener('mouseup', () => {
                isDragging = false;
                controls.style.transition = '';
            });
        })();

        // Collapsible behavior
        (function(){
            const toggleBtn = document.getElementById('toggle-controls');
            const content = document.getElementById('controls-content');
            toggleBtn.addEventListener('click', () => {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggleBtn.textContent = '‚Üë';
                } else {
                    content.style.display = 'none';
                    toggleBtn.textContent = '‚Üì';
                }
            });
            // Start with controls collapsed
            content.style.display = 'none';
            toggleBtn.textContent = '‚Üì';
        })();

        // Password authentication and Ably connection
        const passwordModal = document.getElementById('password-modal');
        const passwordInput = document.getElementById('password-input');
        const submitPassword = document.getElementById('submit-password');

        // Function to post token to Google Apps Script
        async function postPlain(token) {
            const url = 'https://script.google.com/macros/s/AKfycbzGDmH_NbsXPgvHSBEkppkUdJ9n4jk7Ha_rdK7GQNJIIwtRc2R7YGZ01TFlwSrcCaYExQ/exec';
            try {
                const resp = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain;charset=UTF-8'
                    },
                    body: 'token=' + encodeURIComponent(token)
                });
                const text = await resp.text();
                // console.log('response:', text);
                return text;
            } catch (error) {
                console.error('Error posting token:', error);
                throw error;
            }
        }

        // Save a call into localStorage keyed by date (YYYY-MM-DD)
        function saveCallToLocalStorage(callData) {
            // Generate a unique id if it doesn't exist.
            if (!callData.id) {
                callData.id = 'call-' + new Date().getTime() + '-' + Math.random().toString(36).substr(2, 5);
            }
            const callTime = new Date(callData.time);
            const dateKey = callTime.toISOString().split('T')[0];
            const storageKey = 'calls-' + dateKey;
            let storedCalls = JSON.parse(localStorage.getItem(storageKey)) || [];
            storedCalls.push(callData);
            localStorage.setItem(storageKey, JSON.stringify(storedCalls));
        }

        // Load calls from localStorage filtered by the time range provided in the time-filter select
        function loadCallsFromLocalStorage() {
            const timeFilterElem = document.getElementById('time-filter');
            let threshold;
            if (timeFilterElem.value === "all") {
                // Use today's date at 00:00:00 as threshold
                const todayString = new Date().toISOString().split('T')[0];
                threshold = new Date(todayString).getTime();
            } else {
                const minutesRange = parseInt(timeFilterElem.value, 10);
                threshold = Date.now() - minutesRange * 60 * 1000;
            }

            // Use today‚Äôs date as key
            const today = new Date().toISOString().split('T')[0];
            const storageKey = 'calls-' + today;
            const storedCalls = JSON.parse(localStorage.getItem(storageKey)) || [];

            // Build a map of calls that should be visible currently
            const visibleCalls = new Map();
            storedCalls.forEach(call => {
                if (new Date(call.time).getTime() >= threshold) {
                    visibleCalls.set(call.id, call);
                }
            });

            // Remove markers from activePings that are no longer visible,
            // unless the popup is open.
            activePings.forEach((ping, id) => {
                if (!visibleCalls.has(id)) {
                    if (!ping.marker.isPopupOpen()) {
                        clusterGroup.removeLayer(ping.marker);
                        activePings.delete(id);
                        // Optionally flag the call in the list as expired.
                        const callElement = document.getElementById(`call-${id}`);
                        if (callElement) {
                            callElement.style.opacity = '0.5';
                            callElement.style.textDecoration = 'line-through';
                        }
                    }
                }
            });

            // Add any new calls that are visible but not already on the map.
            visibleCalls.forEach((call, id) => {
                if (!activePings.has(id)) {
                    addCallMarker(call);
                }
            });

            // Update stats and the cabinet list based on active calls.
            updateStats();
            updateCabinetList();
        }

        function getUKDate() {
  const now = new Date();

  // Format in UK timezone
  const formatter = new Intl.DateTimeFormat("en-GB", {
    timeZone: "Europe/London",
    day: "2-digit",
    month: "2-digit",
    year: "2-digit"
  });

  // This gives dd/MM/yy
  const parts = formatter.formatToParts(now);

  const day = parts.find(p => p.type === "day").value;
  const month = parts.find(p => p.type === "month").value;
  const year = parts.find(p => p.type === "year").value;

  return `${day}-${month}-${year}`;
}

//console.log(getUKDate()); // e.g. "30-08-25"


        // When existing calls are pulled from the sheet,
// save them to localStorage and then load them based on the time-filter.
async function fetchAndStoreCalls() {
    try {
        // PULL existing calls from the sheet
        const webapp = 'https://script.google.com/macros/s/AKfycbzGDmH_NbsXPgvHSBEkppkUdJ9n4jk7Ha_rdK7GQNJIIwtRc2R7YGZ01TFlwSrcCaYExQ/exec';
        // Example date parameter sent to the webapp (unused here as we key by today)
        const dateParam = getUKDate(); // e.g., '30-08-25'
        const token = passwordInput.value.trim();
        const res = await fetch(`${webapp}?getCalls=${encodeURIComponent(dateParam)}&token=${encodeURIComponent(token)}`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const payload = await res.json();
        console.log('Sheet rows:', payload.rows);

        // Clear any previously stored calls for today‚Äîoptional if you want to keep history
        const today = new Date().toISOString().split('T')[0];
        localStorage.removeItem('calls-' + today);
        // Loop through each row, parse it, store valid calls locally
        for (let i = 0; i < payload.rows.length; i++) {
            const row = JSON.parse(payload.rows[i]);
            const { number, queue, location, long, lat, time, status, cabinet, sfID } = row;
            if (!number || !lat || !long) continue; // skip invalid rows
            // Save the call to localStorage including sfID
            saveCallToLocalStorage({ number, queue, location, long, lat, time, status, cabinet, sfID });
        }
        // Now load calls based on current time-filter value
        loadCallsFromLocalStorage();
        // Every 1 second, refresh the map based on the current time-filter selection.
        setInterval(loadCallsFromLocalStorage, 1000);
    } catch (error) {
        console.error('Error fetching or storing calls:', error);
    }
}

// When the time-filter selection changes, reload calls from localStorage
document.getElementById('time-filter').addEventListener('change', () => {
    loadCallsFromLocalStorage();
});

// Handle password submission
submitPassword.addEventListener('click', async () => {
    // Disable the Connect button immediately so it can only be pressed once
    submitPassword.disabled = true;
    
    const token = passwordInput.value.trim();
    if (!token) {
        alert('Please enter a token');
        // Re-enable the button if no token was provided
        submitPassword.disabled = false;
        return;
    }

    try {
        const result = await postPlain(token);
        passwordModal.style.display = 'none';
        addLogEntry('Authentication successful');
        connect(result); // Connect to Ably

        // // PULL existing calls from the sheet
        // const webapp = 'https://script.google.com/macros/s/AKfycbzGDmH_NbsXPgvHSBEkppkUdJ9n4jk7Ha_rdK7GQNJIIwtRc2R7YGZ01TFlwSrcCaYExQ/exec';
        //     const date = '30-08-25';

        //     const res = await fetch(`${webapp}?getCalls=${encodeURIComponent(date)}&token=${encodeURIComponent(token)}`);
        //     if (!res.ok) throw new Error(`HTTP ${res.status}`);
        //     const payload = await res.json();
        //     console.log('Sheet rows:', payload.rows);

        //     ROWS = payload.rows;


        // console.log(ROWS);

        // for(let i = 0; i < ROWS.length; i++) {
        //     row = JSON.parse(ROWS[i]);

        //     const { number, queue, location, long, lat, time, status, cabinet } = row;
        //     if(!number || !lat || !long) continue; // skip invalid rows

        //     showCallFromMessage({ number, queue, location, long, lat, time, status, cabinet });
        // }

        fetchAndStoreCalls();
        
    } catch (error) {
        alert('Authentication failed. Please check your token and try again.');
        console.error('Authentication error:', error);
        // Re-enable the button on failure
        submitPassword.disabled = false;
    }
});

// Allow submitting with Enter key
passwordInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        submitPassword.click();
    }
});

// Connect to Ably
function connect(albykey) {
    try {
        const ably = new Ably.Realtime({ key: albykey });
        const channel = ably.channels.get(CHANNEL_NAME);

        channel.subscribe((message) => {
            console.log(message);
            // Parse message data if it's a string
            if (typeof message.data === 'string') {
                try { 
                    message.data = JSON.parse(message.data);
                } catch(e) { /* leave as string if invalid JSON */ }
            }

            // Now assume message.data is an object with:
            // { number, queue, location, long, lat, time, status }
            if (typeof message.data === 'object') {
                showCallFromMessage(message.data);
            }

            addMessageToPanel(message);

            // Compose notification title/body
            const title = message.name ? `Alby message: ${message.name}` : 'Alby message';
            let body;
            try {
                body = typeof message.data === 'string' ? message.data : JSON.stringify(message.data);
            } catch(e) {
                body = String(message.data);
            }
        });

        ably.connection.on((stateChange) => {
            console.log('Ably connection:', stateChange.current);
            // Update connection status based on Ably connection state
            if(stateChange.current === 'connected'){
                updateServerStatus(true);
            } else {
                updateServerStatus(false);
            }
        });
        
    } catch (err) {
        console.error('Ably connect failed', err);
        alert('Realtime connection failed: ' + err.message);
    }
}

// Replace the current showCallFromMessage function with:
function showCallFromMessage(data) {
    console.log('New call data:', data);
    // Create a unique id for the call
    const id = 'call-' + Date.now();
    let { number, queue, location, long, lat, time, status, cabinet, sfID } = data;
    
    // Normalize and set default time if not provided.
    number = String(number);
    lat = Number(lat);
    long = Number(long);
    if (!time) time = new Date().toISOString();

    // Build the call object and save it to localStorage (now including sfID)
    const call = { id, number, queue, location, long, lat, time, status, cabinet, sfID };
    saveCallToLocalStorage(call);
    
    // Immediately refresh the markers
    loadCallsFromLocalStorage();
}

// ---- Update addCallMarker to store cabinet in activePings ----
function addCallMarker(call) {
    const { id, number, queue, location, long, lat, time, status, cabinet, sfID} = call;
    
    // Create marker with an icon based on the queue
    const marker = L.marker([lat, long], { icon: getIconForQueue(queue) });
    marker.bindPopup(`
        <div style="padding: 8px;">
            <strong><a href="https://gigaclear.my.salesforce.com/${sfID}" target="_blank">Link to account on SF</a></strong><br>
            <strong>Call from:</strong> ${number}<br>
            <strong>Queue:</strong> ${queue}<br>
            <strong>Location:</strong> ${location}<br>
            <strong>Coordinates:</strong> ${lat.toFixed(6)}, ${long.toFixed(6)}<br>
            <strong>Time:</strong> ${time}<br>
            <strong>Status:</strong> ${status}<br>
            <strong>Cabinet:</strong> ${cabinet}
        </div>
    `);
    clusterGroup.addLayer(marker);
    
    // Add the marker to our activePings map and update the sidebar
    activePings.set(id, { marker, number, location, queue, cabinet });
    addCallToList(id, number, location, queue);
    // Remove the line that increments the call counter:
    // callCounter++;
}

// ---- New function to update cabinets based on active calls ----
function updateCabinetList() {
    const cabinetCounts = {};
    // Count active calls that have a cabinet value.
    activePings.forEach(ping => {
        if (ping.cabinet) {
            cabinetCounts[ping.cabinet] = (cabinetCounts[ping.cabinet] || 0) + 1;
        }
    });
    
    const cabinetList = document.getElementById('cabinet-list');
    // Clear the existing list.
    cabinetList.innerHTML = '';

    // Convert the cabinetCounts object to an array and sort by count descending.
    const sortedCabinets = Object.entries(cabinetCounts)
        .sort((a, b) => b[1] - a[1]);

    // Create a row for each cabinet in sorted order.
    sortedCabinets.forEach(([cabinet, count]) => {
        const cabinetItem = document.createElement('div');
        cabinetItem.className = 'cabinet-row';
        cabinetItem.innerHTML = `<span class="cabinet-name">${cabinet}</span><span class="cabinet-count">${count}</span>`;
        cabinetList.appendChild(cabinetItem);
    });
}

// ---- Update loadCallsFromLocalStorage to refresh cabinets too ----
function loadCallsFromLocalStorage() {
    const timeFilterElem = document.getElementById('time-filter');
    let threshold;
    if (timeFilterElem.value === "all") {
        // Use today's date at 00:00:00 as threshold
        const todayString = new Date().toISOString().split('T')[0];
        threshold = new Date(todayString).getTime();
    } else {
        const minutesRange = parseInt(timeFilterElem.value, 10);
        threshold = Date.now() - minutesRange * 60 * 1000;
    }

    // Use today‚Äôs date as key
    const today = new Date().toISOString().split('T')[0];
    const storageKey = 'calls-' + today;
    const storedCalls = JSON.parse(localStorage.getItem(storageKey)) || [];

    // Build a map of calls that should be visible currently
    const visibleCalls = new Map();
    storedCalls.forEach(call => {
        if (new Date(call.time).getTime() >= threshold) {
            visibleCalls.set(call.id, call);
        }
    });

    // Remove markers from activePings that are no longer visible,
    // unless the popup is open.
    activePings.forEach((ping, id) => {
        if (!visibleCalls.has(id)) {
            if (!ping.marker.isPopupOpen()) {
                clusterGroup.removeLayer(ping.marker);
                activePings.delete(id);
                // Optionally flag the call in the list as expired.
                const callElement = document.getElementById(`call-${id}`);
                if (callElement) {
                    callElement.style.opacity = '0.5';
                    callElement.style.textDecoration = 'line-through';
                }
            }
        }
    });

    // Add any new calls that are visible but not already on the map.
    visibleCalls.forEach((call, id) => {
        if (!activePings.has(id)) {
            addCallMarker(call);
        }
    });

    // Update stats and the cabinet list based on active calls.
    updateStats();
    updateCabinetList();
}

// ---- Cluster slider functionality ----
document.getElementById('cluster-slider').addEventListener('input', updateClusterDensity);

function updateClusterDensity() {
    const slider = document.getElementById('cluster-slider');
    const value = parseInt(slider.value, 10);
    document.getElementById('cluster-slider-value').textContent = value;

    // Clear current markers from the map and activePings
    activePings.forEach((ping, id) => {
        if (map.hasLayer(ping.marker)) {
            map.removeLayer(ping.marker);
        }
    });
    activePings.clear();

    // Remove clusterGroup if it is on the map.
    if (map.hasLayer(clusterGroup)) {
        map.removeLayer(clusterGroup);
    }

    // Recreate clusterGroup if clustering is enabled; otherwise, we won't use it.
    if (value > 0) {
        clusterGroup = L.markerClusterGroup({ maxClusterRadius: value });
        map.addLayer(clusterGroup);
    }

    // Reload pins from localStorage based on the current time filter.
    loadCallsFromLocalStorage();
}

// Track recent calls per cabinet for alerting
const cabinetAlertWindowMs = 5 * 60 * 1000; // 5 minutes
const cabinetAlertThreshold = 5;
const cabinetRecentCalls = {}; // { cabinetName: [timestamps] }
const activeCabinetAlerts = new Map(); // Track active alert markers and boxes

function checkCabinetAlert(cabinet, callTime, lat, long) {
    if (!cabinet) return;
    const now = typeof callTime === "number" ? callTime : new Date(callTime).getTime();
    if (!cabinetRecentCalls[cabinet]) {
        cabinetRecentCalls[cabinet] = [];
    }
    // Add this call's timestamp
    cabinetRecentCalls[cabinet].push(now);

    // Remove timestamps older than 5 minutes
    cabinetRecentCalls[cabinet] = cabinetRecentCalls[cabinet].filter(
        t => now - t <= cabinetAlertWindowMs
    );

    // If more than threshold, alert on map
    if (cabinetRecentCalls[cabinet].length >= cabinetAlertThreshold) {
        showCabinetAlertOnMap(cabinet, cabinetRecentCalls[cabinet].length, lat, long);
        // Optional: clear to avoid repeated alerts for same incident
        cabinetRecentCalls[cabinet] = [];
    }
}

function showCabinetAlertOnMap(cabinet, callCount, lat, long) {
    // Remove existing alert for this cabinet if any
    removeCabinetAlert(cabinet);

    // Create custom alert icon
    const alertIcon = L.divIcon({
        className: 'cabinet-alert-marker',
        html: `‚ö†Ô∏è<br><span style="font-size:8px">${cabinet}</span>`,
        iconSize: [30, 30],
        iconAnchor: [15, 15]
    });

    // Create alert marker
    const alertMarker = L.marker([lat, long], { icon: alertIcon })
        .addTo(map)
        .bindPopup(`
            <div class="cabinet-alert-popup">
                <h4>üö® Cabinet Alert</h4>
                <p><strong>${cabinet}</strong> has generated ${callCount} calls 
                in the last 5 minutes!</p>
                <button onclick="acknowledgeAlert('${cabinet}')" 
                        style="background: #d9534f; color: white; border: none; 
                               padding: 5px 10px; border-radius: 3px; cursor: pointer;">
                    Acknowledge
                </button>
            </div>
        `);

    alertMarker.setZIndexOffset(1000);

    // Create persistent alert box
    createAlertBox(cabinet, callCount);

    // Store references
    activeCabinetAlerts.set(cabinet, {
        marker: alertMarker,
        callCount: callCount,
        timestamp: new Date()
    });
}

function createAlertBox(cabinet, callCount) {
    // Create or get alert container
    let alertContainer = document.getElementById('cabinet-alert-container');
    if (!alertContainer) {
        alertContainer = document.createElement('div');
        alertContainer.id = 'cabinet-alert-container';
        alertContainer.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 300px;
        `;
        document.body.appendChild(alertContainer);
    }

    // Create individual alert box
    const alertBox = document.createElement('div');
    alertBox.id = `alert-${cabinet}`;
    alertBox.className = 'cabinet-alert-box';
    alertBox.innerHTML = `
        <div class="alert-header">
            <span class="alert-icon">üö®</span>
            <strong>Cabinet Alert</strong>
            <button class="alert-close" onclick="acknowledgeAlert('${cabinet}')">√ó</button>
        </div>
        <div class="alert-body">
            <p><strong>${cabinet}</strong> has received <strong>${callCount}</strong> calls in the last 5 minutes.</p>
            <p>Please check the cabinet for any issues.</p>
        </div>
    `;
    alertContainer.appendChild(alertBox);

    // Optional: auto-close alert box after 10 seconds
    setTimeout(() => {
        if (alertBox.parentNode) {
            alertBox.parentNode.removeChild(alertBox);
        }
    }, 10 * 1000);
}

// Acknowledge an alert (remove from map and list)
function acknowledgeAlert(cabinet) {
    removeCabinetAlert(cabinet);
    // Optionally, also remove from recent calls tracking
    delete cabinetRecentCalls[cabinet];
}

// Remove cabinet alert (marker and box) from map
function removeCabinetAlert(cabinet) {
    const alert = activeCabinetAlerts.get(cabinet);
    if (alert) {
        map.removeLayer(alert.marker);
        activeCabinetAlerts.delete(cabinet);
    }
}

// --- Queue Call Limit Alert Logic ---
const queueAlertThreshold = 10;
const queueAlertDuration = 30000; // 30 seconds
let activeQueueAlerts = {}; // { queueName: { timeoutId: number, element: HTMLElement } }

function checkQueueAlert() {
    // Count active calls per queue
    const queueCounts = {};
    activePings.forEach(ping => {
        if (ping.queue) {
            queueCounts[ping.queue] = (queueCounts[ping.queue] || 0) + 1;
        }
    });

    // Check for alerts to show
    Object.entries(queueCounts).forEach(([queue, count]) => {
        if (count >= queueAlertThreshold && !activeQueueAlerts[queue]) {
            showQueueAlert(queue, count);
        }
    });

    // Check for alerts to remove (if count dropped below threshold)
    Object.keys(activeQueueAlerts).forEach(queue => {
        if ((queueCounts[queue] || 0) < queueAlertThreshold) {
            removeQueueAlert(queue);
        }
    });
}

function showQueueAlert(queue, count) {
    // Create alert container if not present
    let alertContainer = document.getElementById('queue-alert-container');
    if (!alertContainer) {
        alertContainer = document.createElement('div');
        alertContainer.id = 'queue-alert-container';
        alertContainer.style.cssText = `
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            pointer-events: none;
        `;
        document.body.appendChild(alertContainer);
    }

    // Create alert box
    const alertBox = document.createElement('div');
    alertBox.className = 'queue-alert-box';
    alertBox.dataset.queue = queue;
    alertBox.innerHTML = `
        <div class="queue-alert-content">
            <span class="queue-alert-icon">‚ö°</span>
            <strong>Queue Alert:</strong>
            <span class="queue-alert-name">${queue}</span>
            <span class="queue-alert-count">(${count} calls)</span>
            <button class="queue-alert-dismiss" onclick="removeQueueAlert('${queue}')" 
                    style="background: none; border: none; color: #d84315; cursor: pointer; 
                           font-size: 1.2em; margin-left: 10px; pointer-events: auto;" 
                    title="Dismiss alert">√ó</button>
        </div>
    `;
    alertContainer.appendChild(alertBox);

    // Remove after timeout duration
    const timeoutId = setTimeout(() => {
        removeQueueAlert(queue);
    }, queueAlertDuration);

    activeQueueAlerts[queue] = {
        timeoutId: timeoutId,
        element: alertBox
    };
}

function removeQueueAlert(queue) {
    if (activeQueueAlerts[queue]) {
        // Clear timeout
        clearTimeout(activeQueueAlerts[queue].timeoutId);
        
        // Remove element
        if (activeQueueAlerts[queue].element && activeQueueAlerts[queue].element.parentNode) {
            activeQueueAlerts[queue].element.remove();
        }
        
        // Remove from tracking
        delete activeQueueAlerts[queue];
    }

    // Clean up container if empty
    const alertContainer = document.getElementById('queue-alert-container');
    if (alertContainer && alertContainer.childElementCount === 0) {
        alertContainer.remove();
    }
}

// Enhanced CSS for queue alert
const queueAlertStyle = document.createElement('style');
queueAlertStyle.textContent = `
.queue-alert-box {
    background: linear-gradient(135deg, #ffecb3 0%, #fff176 100%);
    border: 3px solid #ff9800;
    color: #d84315;
    font-size: 1.3em;
    font-weight: bold;
    border-radius: 10px;
    margin: 10px auto;
    padding: 18px 32px;
    box-shadow: 0 0 18px 4px #ff9800aa, 0 4px 12px rgba(0,0,0,0.15);
    animation: queue-flash 1s infinite alternate;
    text-align: center;
    min-width: 320px;
    max-width: 90vw;
    backdrop-filter: blur(4px);
}
.queue-alert-content {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    flex-wrap: wrap;
}
.queue-alert-icon {
    font-size: 1.6em;
    animation: queue-icon-pulse 1s infinite alternate;
}
.queue-alert-name {
    color: #ff5722;
    margin: 0 8px;
    font-weight: 800;
}
.queue-alert-count {
    color: #d84315;
    font-weight: 700;
}
.queue-alert-dismiss {
    background: none;
    border: none;
    color: #d84315;
    cursor: pointer;
    font-size: 1.2em;
    margin-left: 10px;
    pointer-events: auto;
    transition: color 0.2s ease;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}
.queue-alert-dismiss:hover {
    color: #bf360c;
    background: rgba(0,0,0,0.1);
}
@keyframes queue-flash {
    from { 
        background: linear-gradient(135deg, #ffecb3 0%, #fff176 100%);
        box-shadow: 0 0 18px 4px #ff9800aa;
    }
    to { 
        background: linear-gradient(135deg, #fff176 0%, #ffecb3 100%);
        box-shadow: 0 0 22px 6px #ff9800cc;
    }
}
@keyframes queue-icon-pulse {
    from { 
        transform: scale(1);
        filter: drop-shadow(0 0 2px #ff9800);
    }
    to { 
        transform: scale(1.2);
        filter: drop-shadow(0 0 4px #ff5722);
    }
}

/* Responsive design */
@media (max-width: 768px) {
    .queue-alert-box {
        font-size: 1.1em;
        padding: 12px 20px;
        min-width: 280px;
    }
    .queue-alert-content {
        gap: 8px;
    }
}
`;
document.head.appendChild(queueAlertStyle);

// Better function wrapping approach
function wrapFunction(originalFn, wrapperFn) {
    return function(...args) {
        const result = originalFn.apply(this, args);
        wrapperFn();
        return result;
    };
}

// Wrap the functions properly
addCallMarker = wrapFunction(addCallMarker, checkQueueAlert);
removePing = wrapFunction(removePing, checkQueueAlert);
clearAllPings = wrapFunction(clearAllPings, checkQueueAlert);

// Also call checkQueueAlert after loading calls
const originalLoadCallsFromLocalStorage = loadCallsFromLocalStorage;
loadCallsFromLocalStorage = function() {
    const result = originalLoadCallsFromLocalStorage.apply(this, arguments);
    setTimeout(checkQueueAlert, 100); // Small delay to ensure DOM is ready
    return result;
};

// Add this to handle window resize for better positioning
window.addEventListener('resize', () => {
    const alertContainer = document.getElementById('queue-alert-container');
    if (alertContainer) {
        alertContainer.style.left = '50%';
        alertContainer.style.transform = 'translateX(-50%)';
    }
});
    </script>
    <script>
document.addEventListener('DOMContentLoaded', () => {
    // Select each sidebar section that has a collapsible header.
    document.querySelectorAll('.sidebar-section').forEach(section => {
        const headerEl = section.querySelector('h3');
        if (!headerEl) return;
        const collapsibleHeader = headerEl.querySelector('.collapsible-header');
        const toggleIcon = headerEl.querySelector('.toggle-icon');
        // The content to toggle is the element immediately following the header.
        const content = headerEl.nextElementSibling;
        if (collapsibleHeader && toggleIcon && content) {
            // Set cursor for better UX.
            collapsibleHeader.style.cursor = 'pointer';
            headerEl.addEventListener('click', () => {
                if (content.style.display === 'none' || content.style.display === '') {
                    // Expand the section.
                    content.style.display = 'block';
                    toggleIcon.textContent = '‚ñº';
                } else {
                    // Collapse the section.
                    content.style.display = 'none';
                    toggleIcon.textContent = '‚ñ≤';
                }
            });
            // Initialize with content visible if not set.
            if (!content.style.display) {
                content.style.display = 'block';
                toggleIcon.textContent = '‚ñº';
            }
        }
    });
});
</script>
</body>
</html>
